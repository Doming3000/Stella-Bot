import { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder } from "discord.js";
import dotenv from 'dotenv';
import axios from "axios";

// Cargar variables de entorno
dotenv.config();

export const data = new SlashCommandBuilder()
.setName('malware-scan')
.setDescription('Analiza una URL en busca de malware.')
.addSubcommand(sub =>
  sub
  .setName('url')
  .setDescription('Analiza una URL en busca de malware.')
  .addStringOption(opt =>
    opt
    .setName('url')
    .setDescription('URL a analizar.')
    .setRequired(true)
  )
)
.addSubcommand(sub =>
  sub
  .setName('message')
  .setDescription('Analiza una URL en un mensaje en busca de malware.')
  .addStringOption(opt =>
    opt
    .setName('message-link')
    .setDescription('URL del mensaje a analizar.')
    .setRequired(true)
  )
);

// Función para verificar si una URL es válida
function isValidURL(url) {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
}

// Función para obtener enlaces en un mensaje
function extractMessageURL(content) {
  // Expresión regular para detectar URLs
  const urlRegex = /https?:\/\/[^\s<>\]\)"]+/gi;
  const matches = content.match(urlRegex);
  
  if (!matches || matches.length === 0) return null;
  
  // Contar frecuencia de cada enlace
  const urlFrequency = {};
  for (const url of matches) {
    urlFrequency[url] = (urlFrequency[url] || 0) + 1;
  }
  
  // Ordenar por frecuencia (descendente)
  const sorted = Object.entries(urlFrequency).sort((a, b) => b[1] - a[1]);
  
  // Retornar el primero o el que más se repita
  return sorted[0][0];
}

// Función para crear un delay para el análisis
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Función para manejar errores de la API
async function handleAPIError(error) {
  const response = error.response;
  
  switch (response.status) {
    case 429: {
      await interaction.editReply({ content: "<:Advertencia:1302055825053057084> Se están haciendo demasiadas peticiones, inténtalo nuevamente más tarde.", allowedMentions: { repliedUser: false }});
      return;
    }
    default:
    await interaction.editReply({ content: "<:Advertencia:1302055825053057084> Ha ocurrido un error inesperado.", allowedMentions: { repliedUser: false }});
    return;
  }
}

// Función para ejecutar el análisis de malware
async function malwareScan(client, interaction, url, confirmMessage) {
  // Verificar si el valor proporcionado es una URL válida.
  if (!isValidURL(url)) {
    await interaction.reply({ content: "<:Advertencia:1302055825053057084> Debes proporcionar una URL válida.", flags: 64, allowedMentions: { repliedUser: false }});
    return;
  }
  
  // Envíar mensaje de confirmación
  interaction.reply({ content: confirmMessage, allowedMentions: { repliedUser: false }});
  
  try {
    // Obtener la clave API de VirusTotal
    const apiKey = process.env.VIRUSAPIKEY;
    const virusTotalUrl = `https://www.virustotal.com/api/v3/urls`;
    
    // Paso 1: Enviar la URL para el análisis
    const analysisResponse = await axios.post( virusTotalUrl, `url=${url}`, { headers: { 'x-apikey': apiKey, 'Content-Type': 'application/x-www-form-urlencoded' }});
    const analysisId = analysisResponse.data.data.id;
    const resultUrl = `https://www.virustotal.com/api/v3/analyses/${analysisId}`;
    
    // Paso 2: Consultar el estado del análisis
    let analysisStatus = 'queued';
    const maxRetries = 10;
    let retryCount = 0;
    let resultResponse;
    
    while (analysisStatus !== 'completed' && retryCount < maxRetries) {
      try {
        await delay(5000);
        resultResponse = await axios.get(resultUrl, { headers: { 'x-apikey': apiKey }});
        analysisStatus = resultResponse.data.data.attributes.status;
      } catch (error) {
        const { message } = await handleAPIError(error);
        console.warn(message);
        
        if (retry && retryCount < maxRetries) {
          await delay(delay);
          retryCount++;
        } else {
          throw new Error(message);
        }
      }
    }
    
    if (analysisStatus !== 'completed') {
      await interaction.editReply({ content: "<:Advertencia:1302055825053057084> El análisis no se completó en el tiempo esperado.", allowedMentions: { repliedUser: false }});
      throw new Error("El análisis no se completó en el tiempo esperado. ");
    }
    
    // Paso 3: Obtener resultados y meta información
    const analysisData = resultResponse.data.data.attributes;
    const urlMetaInfo = resultResponse.data.meta.url_info;
    const positives = analysisData.stats.malicious;
    const totalScans = analysisData.stats.undetected + analysisData.stats.malicious + analysisData.stats.suspicious;
    
    // Determinar el estado del enlace analizado
    const linkStatus = positives > 0 ? "No seguro" : "Seguro";
    
    if (!analysisData.results || !urlMetaInfo) {
      await interaction.editReply({ content: "<:Advertencia:1302055825053057084> No se encontraron resultados de análisis para esta URL.", allowedMentions: { repliedUser: false }});
      return;
    }
    
    // Generar el enlace público usando la ID del análisis
    const publicResultUrl = `https://www.virustotal.com/gui/url/${urlMetaInfo.id}/detection`;
    
    // Crear y enviar un embed con los resultados
    const embed = new EmbedBuilder()
    .setColor(positives > 0 ? '#eb5252' : '#68d268')
    .setAuthor({ name: `${client.user.username} - ${interaction.commandName}`, iconURL: client.user.displayAvatarURL()})
    .setTitle(`Análisis terminado: ${linkStatus}`)
    .addFields(
      { name: 'URL analizada', value: `\`${url}\``, inline: false},
      { name: 'Positivos', value: `${positives}/${totalScans}`, inline: true }
    )
    .setFooter({ text: positives > 0 ? 'No se recomienda acceder a esta URL.' : 'La URL es segura, puedes proceder.' });
    
    // Botón para abrir los resultados en el navegador.
    const actionRow = new ActionRowBuilder()
    .addComponents(
      new ButtonBuilder()
      .setEmoji("<:Lista:1327042288941137960>")
      .setLabel("Ver resultados")
      .setURL(`${publicResultUrl}`)
      .setStyle("Link")
    );
    
    // Editar el mensaje de confirmación
    await interaction.editReply({ content: "", embeds: [embed], components: [actionRow], allowedMentions: { repliedUser: false }});
    
    // Obtener el enlace del mensaje
    const originalMessage = await interaction.fetchReply();
    const messageLink = `https://discord.com/channels/${interaction.guildId}/${interaction.channelId}/${originalMessage.id}`;
    
    // Avisar al usuario
    await interaction.followUp({ content: `<:Done:1326292171099345006> <@${interaction.user.id}> El [análisis](${messageLink}) ha finalizado.`, flags: 64, allowedMentions: { repliedUser: false }});
  } catch (error) {
    console.error("Error al realizar el análisis de virus:", error.response ? error.response.data : error.message);
    await interaction.editReply({ content: "<:Advertencia:1302055825053057084> Ha ocurrido un error al ejecutar este comando.", allowedMentions: { repliedUser: false }});
  }
}

// Función run (comando principal)
export async function run(client, interaction) {
  const subcommand = interaction.options.getSubcommand();
  
  // Lógica para manejar la URL
  if (subcommand === 'url') {
    const url = interaction.options.getString('url');
    
    // Variable para el mensaje de confirmación (En caso de URL copiada)
    let confirmMessage = "<:Done:1326292171099345006> **Recibido**. Se está analizando este enlace <a:Loading:1374508429930139780>\n-# Esto puede tardar algún tiempo."
    
    // Llamada a la función para ejecutar el análisis
    await malwareScan(client, interaction, url, confirmMessage);
  }
  
  // Lógica para manejar el enlace del mensaje
  if (subcommand === 'message') {
    const messageLink = interaction.options.getString('message-link');
    
    // Validar y extraer IDs desde el enlace del mensaje
    const match = messageLink.match(/https:\/\/discord\.com\/channels\/(\d+)\/(\d+)\/(\d+)/);
    
    if (!match) {
      await interaction.reply({ content: "<:Advertencia:1302055825053057084> Debes proporcionar una URL de mensaje válida.", flags: 64, allowedMentions: { repliedUser: false }});
      return;
    }
    
    const [_, guildId, channelId, messageId] = match;
    
    try {
      // Obtener el canal y mensaje
      const channel = await client.channels.fetch(channelId);
      const message = await channel.messages.fetch(messageId);
      
      // Extraer la URL del contenido del mensaje
      const extractedUrl = extractMessageURL(message.content);
      
      if (!extractedUrl) {
        await interaction.reply({ content: "<:Advertencia:1302055825053057084> El mensaje no contiene ninguna URL.", flags: 64, allowedMentions: { repliedUser: false }});
        return;
      }
      
      // Variable para el mensaje de confirmación (En caso de URL en un mensaje de Discord)
      let confirmMessage = `<:Done:1326292171099345006> **Recibido**: \`${extractedUrl.substring(0, 30) + (extractedUrl.length > 30 ? '...' : '')}\`\nSe está analizando este enlace <a:Loading:1374508429930139780>\n-# Esto puede tardar algún tiempo.`;
      
      // Ejecutar análisis de malware
      await malwareScan(client, interaction, extractedUrl, confirmMessage);
    } catch (error) {
      console.error("Error al obtener el mensaje:", error);
      await interaction.reply({ content: "<:Advertencia:1302055825053057084> No se pudo encontrar el mensaje. Comprueba que la aplicación tenga permsisos para ver el canal.", flags: 64, allowedMentions: { repliedUser: false }});
    }
  }
}